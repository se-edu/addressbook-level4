= Using PlantUML
:site-section: DeveloperGuide
:imagesDir: images/plantuml
:stylesDir: stylesheets
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]

== Introduction to PlantUML

PlantUML is a popular tool in this project to create UML diagrams.
For more information about the basics of PlantUML, head over to http://plantuml.com/[its official website].

== Set up PlantUML

=== Installing Graphviz

Graphviz is a dependency that PlantUML requires to generate more advanced diagrams.
Head over to the https://www.graphviz.org/download/[downloads page] on the offcial Graphviz website and follow instructions to install Graphviz.

=== Installing the `PlantUML integration` plugin for IntelliJ IDEA

While this is not compulsory, the `PlantUML integration` provides a live preview of the PlantUML file you are working on.

Go to `Settings` > `Other Settings` > `PlantUML` or search for PlantUML.
Configure the path to the `dot` executable.
This executable can be found in the `/bin` directory where you installed GraphViz.

.Settings - Other Settings - PlantUML: input the path to your dot executable
image::ConfiguringGraphviz.png[]

== Create/Edit PlantUML diagrams

After installing the `PlantUML integration` plugin, simply create or open any `.puml` file to start editing it.

.Editing `DeleteSequenceDiagram.puml`
image::EditingDeleteSequenceDiagram.png[]
Any changes you make in editor pane on the left will be reflected in the preview pane on the right.
However, do take note that these changes _will not_ be reflected in the developers guide until you export the diagram.
//TODO: Discussion about why we're not using asciidoctor-diagram

== Export UML diagrams

A helpful Gradle task `:plantUml` is provided to generate all diagrams in the `docs/diagrams` directory and output them in the `.png` format under `docs/images` directory.

NOTE: You will have to `git add` any new diagrams generated!

When editing your documentation, you might find it useful to have Gradle monitor changes to your PlantUML diagrams and and automatically export them.
You can do this by running `gradlew -t plantUml` in a terminal.
The `-t` flag enables _continuous build_ which will watch for changes to files and execute specified tasks.
In this case, gradle will run the task `plantUml` when it detects changes to your PlantUML diagrams.

== Common tasks

=== Applying consistent formatting to PlantUML diagrams

It is highly recommended to consistently color your UML diagrams as an visual aid.
You can achieve this by creating a dictionary of colors and import it Ã  la CSS

For example, you can create a `Style.puml` with the contents

.Style.puml
[source]
----
...
!define LOGIC_COLOR #3333C4
!define LOGIC_COLOR_T1 #7777DB
!define LOGIC_COLOR_T2 #5252CE
!define LOGIC_COLOR_T3 #1616B0
!define LOGIC_COLOR_T4 #101086
...
----

and use it in another PlantUML file like this:

.UndoSequenceDiagram.puml
[source]
----
!include Style.puml

box Logic LOGIC_COLOR_T2
participant ":LogicManager" as LogicManager LOGIC_COLOR
participant ":AddressBookParser" as AddressBookParser LOGIC_COLOR
participant ":UndoCommand" as UndoCommand LOGIC_COLOR
end box
----

You can fine-tune the formatting of PlantUML diagrams with the `skinparam` command.
For example, `skinparam backgroundColor transparent` turns the background of the diagram transparent.

For a comprehensive list of ``skinparam``s head over to the link:https://plantuml-documentation.readthedocs.io/en/latest/[unofficial PlantUML skinparam documentation].

***

=== Repositioning elements in PlantUML diagrams

While PlantUML's automatic layout engine usually produces satisfactory results, it is not uncommon to get a lemon, especially on larger diagrams.

.The UI class diagram without additional formatting
image::RawUiDiagram.png[]

NOTE: In most cases, you should consider decomposing the diagram into smaller ones or focusing on a more specific portion of the diagram.

Here are some of the techniques we used in this project to obtain a more palatable diagram.

==== Link lengths
By default, a short link (`->`) points to right and a long link (`-->`)
points downwards. you can extend any link to make it longer (`-->`).

.Length of arrows and its effects
image::ArrowLength.png[]

==== Link directions
Clever usage of arrow directions will resolve most layout issues.
For example, the table below shows how the way in which you specify arrows can results in drastically different layouts for the same diagram.

.Link directions
[cols="40a,60a"]
|===
|Source |Result

|[source, puml]
----
A --> Z
B --> Z
C --> Z
D --> Z

A --> 1
B --> 2
C --> 3
D --> 4
----
|image::AllDown.png[]

|[source, puml]
----
'default is down
A --> Z
'specify down
B -down-> Z
'shorthand for down
C -d-> Z
'arrow lengths take priority
D -down> Z

A -up-> 1
B -up-> 2
C -up-> 3
D -up-> 4

----
|image::UpAndDown.png[]

|[source, puml]
----
A -up-> Z
B -up-> Z
C -up-> Z
D -up-> Z

A --> 1
B --> 2
C --> 3
D --> 4

'Force A B C D
A -right[hidden]- B
B -right[hidden]- C
C -right[hidden]- D
----
|image::HiddenArrows.png[]
|===

==== Reordering definitions
As a general rule of thumb, the layout engine will attempt to order objects in the order in which they are defined.
If there is no formal definition, the objects is taken to be declared upon its first usage.

.Definition ordering and outcomes
[cols="70a,30a"]
|===
|Source |Result

|[source, puml]
----
A --> B
C --> D
----
|image::ABeforeC.png[]

|[source, puml]
----
'Class C is defined before A
Class C

A --> B
C --> D
----
|image::CBeforeA.png[]

|[source, puml]
----
package "Rule Of Thumb"{
    Class C
    A --> B
    C --> D
}
----
|image::PackagesAndConsistency.png[]
|===

TIP: Explicitly define all symbols to avoid any potential layout mishaps.
